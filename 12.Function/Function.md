# 12. 함수(Function)

### 1. 함수란?
 - 자바스크립트에서 가장 중요한 핵심 개념
 - 입력을 받아 출력을 내보내는 일련의 과정을 정의
 - 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의
 - 함수 정의를 통해 생성
    ```javascript
   //함수정의
    function add(x, y){
        return x + y;
    }
   
   //함수호출
   let result = add(2, 5);
    ```
   
### 2. 함수를 사용하는 이유
 - 코드의 재사용성이라는 측면에서 매우 유용하기 때문
 - 유지보수의 편의성을 높이고, 코드의 신뢰성을 높임
 - 적절한 함수 이름은 코드의 가독성을 향상시킴

### 3. 함수 리터럴
 - JS의 함수는 객체 타입의 값이다
 - 함수 리터럴은 function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성된다.
 - 함수 리터럴은 함수 몸체 내에서만 참조할 수 있는 식별자다
    ```javascript
   //변수에 함수 리터럴을 할당
    let result = function add(x, y){
        return x + y;
    }
    ```
 | 구성 요소 | 설명                                                                                                            |
 |---------------------------------------------------------------------------------------------------------------|---|
 | 함수 이름 | - 함수 이름은 식별자이므로 네이밍 규칙을 준수해야함<br/> - 함수 이름은 함수 몸체내에서만 참조할 수 있는 식별자<br/> - 함수명은 생략 가능. 이름이 있으면 기명함수, 없으면 무기명 함수 |
 |매개변수 목록| - 순서에 의미가 있음<br/> - 식별자 네이밍 규칙을 준수해야함                                                                         |
 |함수 몸체| - 호출 시 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록                                                                     |

### 4. 함수 정의
 - 변수 선언과 동일한 의미임

   1. 함수 선언문
       - 함수 리터럴과 같은 형태이나, 함수 리털럴과는 달리 이름 생략 불가능
      ```javascript
      function add(x, y){
           return x + y;
      }
       ```
      - 표현식이 아닌 문
      - 기명 함수 리터럴은 코드의 문맥에 따라 함수 선언문 또는 함수 리터럴 표현식으로 해석된다.
      - JS 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 함수 객체를 할당함
      
   2. 함수 표현식
      - 값의 성질을 갖는 객체를 일급 객체라고 하고, JS의 함수는 일급 객체이다
      - 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 생성할 수 있다
      - 함수 표현식의 함수 리터럴은 이름을 생략하는 것이 일반적이다.
      - 표현식인 문
      ```javascript
      let result = function add(x, y){
         return x + y;
      }
      console.log(result(3, 5));
      ```
   3. 함수 생성 시점과 함수 호이스팅
      - 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다름
      - 함수 선언문은 런타임 이전 JS 엔진에 의해 먼저 실행된다.
      - 함수 선언문이 코드의 선두로 끌어 올려진 것 같처럼 동작하는 JS 고유의 특징을 함수 호이스팅이라 함
      - 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출 가능함
      - 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.
   4. Function 생성자 함수
      - new 연산자와 함꼐 호출하면 함수 객체를 생성해서 반환하며, new  연산자 없이 호출해도 결과는 동일함
      ```javascript
        let result = new Function('x', 'y', 'return x + y');
        console.log(result(3, 5));
      ```
      - 일반적이지도, 바람직하지도 않은 방법임
      - 클로저를 생성하지 않는 등 함수 선언문이나 표현식으로 생성한 함수와는 다르게 동작함
   5. 화살표 함수
      - ES6에 도입
      ```javascript
        const add = (x, y) => x+y;
      ``` 
      - 항상 익명 함수로 정의함
      - 생성자 함수로 사용할 수 없음
      - 기존 함수와 this 바인딩 방식이 다름
      - property 가 없음
      - arguments 객체 생성하지 않음

### 5. 함수 호출
 - 매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내에서는 변수와 동일하게 취급
 - 매개변수의 개수와 인수의 개수가 일치하는지 체크하지는 않는다
 - 매개변수보다 인수가 더 많을 경우 초과된 인수는 arguments 객체의 프로퍼티로 보관되나 사용하지는 않는다
 - 매개변수 기본값을 사용하면 에러를 줄일 수 있음
      ```javascript
      function add(a = 0, b=0, c=0){
        return a+b+c;
      }
      ``` 
 - 이상적인 함수는 한 번에 한 가지 일만 하며 가급적 작게 만들어야 함
 - 매개변수도 많으면 좋지 않다
 - 함수 표현식에서 반환문을 생략할 경우 암묵적으로 undefined 를 반환함

### 6. 참조에 의한 전달과 외부 상태의 변경
 - 함수를 호출하면 매개변수에 값을 전달하는 방식 call by value, call by reference 
 - 원시 값인 경우 값을 변경해도 원본은 훼손되지 않으나, 객체인 경우 원본이 훼손된다
 - 객체의 변경을 추적하려면 옵저버 패턴 등을 통해 객체를 참조 공유하는 모든 이들에게 변경사항을 통지하고 추가 대처가 필요하다
 - 이러한 문제를 해결하기 위해서는 객체를 불변 객체로 만들어서 사용하기도 한다
 - 이를 통해 객체의 상태 변경을 원천 봉쇄하고 객체의 상태 변경이 필요한 경우에는 객체의 방어적 복사 즉, 원본 객체의 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체하여 부수 효과를 없앨 수 있다
 - 외부 상태를 변경하지도 않고, 외부 상태에 의존하지도 않는 함수를 순수 함수라 한다

### 7. 함수의 다양한 형태
 1. 즉시 실행 함수
    - 함수 정의와 동시에 즉시 호출되는 함수
    - 단 한 번만 호출되며 다시 호출할 수 없음
    - 익명 함수를 사용하는 것이 일반적이다.
    - 반드시 그룹 연산자 () 로 감싸야 함
    - 일반 함수처럼 값을 반환하거나 인수를 전달할 수 있음
    ```javascript
    //익명
    (function (){
        let a = 3;
        let b = 5;
        return a * b;
    }());
    //기명
    (function foo(){
        let a = 3;
        let b = 5;
        return a * b;
    }());
    foo(); // ReferenceError foo is not defined
    ``` 
 2. 재귀함수
    - 자기 자신을 호출하는 함수
    - 반복되는 처리를 위해 사용함
    - 탈출 조건을 반드시 만들어야 하며, 만들지 않을 경우 스택 오버플로우가 발생함
 3. 중첩함수
    - 함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라고 한다.
    - 중첩 함수를 포함하는 함수는 외부 함수라 부른다
    - 일반적으로 중첩 함수는 외부 함수를 돕는 헬퍼 함수의 역할을 한다
    - 중첩 함수는 스코프와 클로저에 깊은 과련이 있음
      ```javascript
      function outer(){
        let x = 1;
            
        // 중첩함수
        function inner(){
            let y = 2;
            console.log(x + y);
        }
        
        inner();
      }
      outer();
      ``` 
      
 4. 콜백함수
    - JS 의 함수는 일급 객체이므로 함수의 매개변수를 통해 함수를 전달할 수 있음
    - 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 함
    - 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다
    - 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출함
    - 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있음
    
 5. 순수 함수와 비순수 함수
    - 순수 함수는 부수 효과가 없는 함수
    - 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수임
    - 즉, 순수 함수는 외부 상태에 의존하지 않고, 매개변수에만 의존해 반환값을 만든다
    - 비순수 함수는 외부 상태에 의존하거나 외부 상태를 변경하는(= 부수효과가 있는) 함수
    - 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임
